1
00:00:01,310 --> 00:00:07,720
Encryption provides confidentiality. But we
also need integrity. Fo a system to be secure,

2
00:00:07,720 --> 00:00:11,750
we need to know that a message was actually
generated by someone else and no-one has modified

3
00:00:11,750 --> 00:00:17,990
it. For example, suppose we want a secure
file system protocol. Without integrity, an

4
00:00:17,990 --> 00:00:22,779
adversary could append garbage data to writes,
or potentially create new write commands with

5
00:00:22,779 --> 00:00:24,419
garbage data.

6
00:00:24,419 --> 00:00:28,749
The basic point is that secrecy is not enough.
Encryption can prevent someone from reading

7
00:00:28,749 --> 00:00:31,710
our messages, but it doesn’t protect them
from tampering.

8
00:00:31,710 --> 00:00:38,320
The second property of secure systems, besides
confidentiality, is integrity. Integrity algorithms

9
00:00:38,320 --> 00:00:43,280
let you know for sure that a message was generated
by someone with the key. So assuming the key

10
00:00:43,280 --> 00:00:47,930
is secret, you can be assured it came from
a specific program, host, et cetera. This

11
00:00:47,930 --> 00:00:52,770
is really useful. For example, with integrity
you can know that a routing vector actually

12
00:00:52,770 --> 00:00:56,680
came from the node it’s supposedly from,
an an adversary isn’t trying to trick you

13
00:00:56,680 --> 00:01:00,800
to route traffic through them. You can know
that the person who’s making a bid in an

14
00:01:00,800 --> 00:01:05,920
auction actually made that bid. And you can
know, if you receive a message to terminate

15
00:01:05,920 --> 00:01:09,539
a connection, or a bad message that might
cause you to terminate the connection, that

16
00:01:09,539 --> 00:01:13,380
the message actually came from the other endpoint
and isn’t someone trying to shut down the

17
00:01:13,380 --> 00:01:18,909
connection on you.
Generally speaking, integrity usually comes

18
00:01:18,909 --> 00:01:24,119
first. There are lots of cases where you want
integrity but confidentiality isn’t that

19
00:01:24,119 --> 00:01:31,119
important, but it’s rare that you want confidentiality
but not integrity.

20
00:01:31,189 --> 00:01:36,740
Cryptographic hashes and message authentication
codes are two major integrity primitives.

21
00:01:36,740 --> 00:01:41,240
Cryptographic hashes let you safely determine
that data hasn’t been modified. Anyone can

22
00:01:41,240 --> 00:01:47,189
generate a cryptographic hash. They require
no key. It’s a hash function with some special

23
00:01:47,189 --> 00:01:53,719
properties. Cryptographic hashes are useful
for storing data. You can be sure no-one has

24
00:01:53,719 --> 00:01:58,789
tampered with the data. And since no key is
needed, anyone can check that the data hasn’t

25
00:01:58,789 --> 00:02:04,600
been tampered with.
Message authentication codes, or MACs, are

26
00:02:04,600 --> 00:02:09,429
a second way to verify that data hasn’t
been modified. They have all of the integrity

27
00:02:09,429 --> 00:02:14,540
properties that cryptographic hashes do. But
they have the additional property that they

28
00:02:14,540 --> 00:02:20,700
ensure that the person who generated the MAC
has a key. Only somone else with the same

29
00:02:20,700 --> 00:02:25,810
key can check that the MAC is correct. So
message authentication codes are useful in

30
00:02:25,810 --> 00:02:29,610
networks. If you send a message with a MAC
appended to it, the receiver, if they have

31
00:02:29,610 --> 00:02:34,110
the corresponding key, can check that the
message they receive is the message you sent,

32
00:02:34,110 --> 00:02:39,450
and that you sent it, since you had to have
the key to generate the MAC. In that way,

33
00:02:39,450 --> 00:02:46,450
MACs also provide authentication, hence their
name.

34
00:02:49,310 --> 00:02:55,280
A cryptographic hash is a hash function with
some special properties. Like an ordinary

35
00:02:55,280 --> 00:03:01,250
hash function, a cryptographic hash produces
a fixed length output from an arbitrary length

36
00:03:01,250 --> 00:03:07,340
input. For example, I can compute a 256 bit
hash from a gigabyte of data. They’re generally

37
00:03:07,340 --> 00:03:13,860
really fast to compute, faster than the network.
Cryptographic hashes, like normal hash functions,

38
00:03:13,860 --> 00:03:18,269
typically work by performing a single scan
over the data and performing some mathematical

39
00:03:18,269 --> 00:03:22,560
operations based on each byte or word. That
way you don’t have to keep the entire data

40
00:03:22,560 --> 00:03:28,069
in memory at once, you can just stream through
it.

41
00:03:28,069 --> 00:03:32,560
Cryptographic hashes provide the property
that they are *collision resistant*. What

42
00:03:32,560 --> 00:03:39,219
this means is that if I have some data x and
a hash H(x), then it is intractable to generate

43
00:03:39,219 --> 00:03:46,219
a y such that hash of y is equal to hash of
x. Of course, there are many such collisions.

44
00:03:47,359 --> 00:03:54,359
Let’s say that I have a 256 bit cryptographic
hash. There are 2 to the 256 different values.

45
00:03:55,709 --> 00:04:02,629
Let’s say that I’m hashing 1 gigabyte
of data. Well, there are 2 to the 30 bits,

46
00:04:02,629 --> 00:04:09,629
so 2 to the 2 to the 30 different blocks of
data, but only two the 256 different hashes.

47
00:04:12,319 --> 00:04:17,200
While such collisions exist, they are very
difficult to find, such that people spend

48
00:04:17,200 --> 00:04:24,200
years trying to do so and don’t. You can’t
just try two to the 128 different data blocks.

49
00:04:24,660 --> 00:04:31,660
This is a very deep idea: make sure you understand
it. Given a hash value H, it is intractable

50
00:04:33,259 --> 00:04:39,699
to generate a piece of data that has that
hash value. This seems very simple, but it

51
00:04:39,699 --> 00:04:45,750
is amazingly powerful. Given a hash value
H, it is intractable to generate a piece of

52
00:04:45,750 --> 00:04:51,520
data that has that hash value.
If you need to use a hash function, use SHA-256

53
00:04:51,520 --> 00:04:58,520
or SHA-512. These are the SHA-2 (secure hash
algorithm 2) algorithm with either 256 or

54
00:04:59,110 --> 00:05:06,110
512 bit hashes. SHA-1 is nearly broken today.
There’s also SHA-3, which the National Institute

55
00:05:06,160 --> 00:05:11,039
of Standards and Technology selected in October
2012 to be an alternative hash to SHA-2 which

56
00:05:11,039 --> 00:05:16,930
is just as strong but based on different mathematical
principles. That way, if there’s something

57
00:05:16,930 --> 00:05:22,060
wrong with SHA-2 we’ll have an already vetted
algorithm to fall back on.

58
00:05:22,060 --> 00:05:27,660
Now, SHA-2 was designed by the National Security
Agency, or NSA, and published in 2001. Given

59
00:05:27,660 --> 00:05:31,030
all of the recent press on the NSA trying
to build back doors, you might think there’s

60
00:05:31,030 --> 00:05:36,880
one in SHA-2. But chances are there aren’t.
It’s been around for over a decade, and

61
00:05:36,880 --> 00:05:41,940
was vetted in a public process. Anyone who’s
anyone in cryptography and security has taken

62
00:05:41,940 --> 00:05:47,930
a look, and it seems fine. Breaking SHA-2
would be the equivalent of developing Einstein’s

63
00:05:47,930 --> 00:05:54,030
theory of relativity in physics. SHA-3 was
designed by a group of security researchers

64
00:05:54,030 --> 00:06:01,030
and won a competition sponsored by NIST to
for the new SHA-3.

65
00:06:01,960 --> 00:06:07,099
Cryptographic hashes have this nice property
that a small hash uniquely describes a large

66
00:06:07,099 --> 00:06:13,220
piece of data. The basic approach is this.
Take your file, and compute its hash, store

67
00:06:13,220 --> 00:06:20,220
this as h1. Later, compute the hash on the
file again. Let’s call this hash value h2.

68
00:06:20,270 --> 00:06:24,310
If the new value doesn’t match the old one,
then something has changed in the file. If

69
00:06:24,310 --> 00:06:28,840
the two are equal then you know the file hasn’t
been tampered with, because someone couldn’t

70
00:06:28,840 --> 00:06:33,699
generate a few file, or change the existing
file, so that it has the same hash value.

71
00:06:33,699 --> 00:06:38,300
So something you sometimes see when you download
software is someone publishes the hash of

72
00:06:38,300 --> 00:06:42,569
the software along side with the program.
You can then check that what you’ve downloaded

73
00:06:42,569 --> 00:06:47,650
is what they produced, and so nobody has inserted
malware into the distribution after it was

74
00:06:47,650 --> 00:06:50,610
released.
One neat way you can use hashes is something

75
00:06:50,610 --> 00:06:56,389
called a Merkle hash tree. So by themselves,
cryptograph hashes just tell you if the data

76
00:06:56,389 --> 00:07:02,379
has been modified. If I have a huge file,
I can tell it’s been modified, but not where.

77
00:07:02,379 --> 00:07:06,889
If you build a Merkle tree, you can tell what
part of the file has been modified. You hash

78
00:07:06,889 --> 00:07:12,210
small blocks of the file, then create a tree
of hashes, like shown here. If the top-level

79
00:07:12,210 --> 00:07:16,470
hash differs, then you know the files differ.
You can then walk down the trees and in a

80
00:07:16,470 --> 00:07:22,639
logarithmic number of steps figure out what
part of the files differ. So if someone has

81
00:07:22,639 --> 00:07:26,860
tampered with your file, you can see if it’s
because someone truncated it by accident or

82
00:07:26,860 --> 00:07:33,349
inserted malicious ode.

83
00:07:33,349 --> 00:07:38,139
Cryptographic hashes are very useful and tell
you nobody has modified the data, but they

84
00:07:38,139 --> 00:07:45,139
don’t require a secret. Anyone can generate
a cryptographic hash. Message authentication

85
00:07:48,430 --> 00:07:53,330
codes, though, want to provide authenticity
as well. You want to be sure that the program

86
00:07:53,330 --> 00:07:59,939
that generated the MAC has a secret.
Building message authentication codes is easy

87
00:07:59,939 --> 00:08:04,449
once we have cryptographic hashes. All we
need to do is incorporate the secret into

88
00:08:04,449 --> 00:08:10,699
the hash. We can define a message authentication
code algorithm, HMAC, which takes a key K

89
00:08:10,699 --> 00:08:15,669
and a message M. All it does is prepend the
key to the message and compute a hash over

90
00:08:15,669 --> 00:08:20,939
that data. We can then send just the message
and the MAC. To check the message authentication

91
00:08:20,939 --> 00:08:26,639
code, the receiver prepends the key, and computes
the MAC. They know only someone with the key

92
00:08:26,639 --> 00:08:30,449
could produce the MAC.
So, it’s simple: we have a cryptographically

93
00:08:30,449 --> 00:08:33,380
strong MAC!

94
00:08:33,380 --> 00:08:37,550
WRONG!
Recall that hash functions work by iterating

95
00:08:37,549 --> 00:08:42,348
over the data. For most hash functions, this
means you incorporate the new data into the

96
00:08:42,349 --> 00:08:47,320
existing hash value. Put another way, the
hash value is the intermediate state of the

97
00:08:47,320 --> 00:08:53,750
computation. This means that if I see message
M has a certain MAC, then I can append some

98
00:08:53,750 --> 00:08:57,870
data to M, making M-prime, and compute the
MAC for M-prime.

99
00:08:57,870 --> 00:09:04,870
So, as it always seems with security, the
simple approach doesn’t work and has vulnerabilities.

100
00:09:05,700 --> 00:09:09,700
We need to do something smarter.

101
00:09:09,700 --> 00:09:16,700
Luckily, that smarter approach is not much
more complex. Here’s the right way to compute

102
00:09:17,170 --> 00:09:23,410
a message authentication code. Take your key
K, and XOR it with an inner pad, say 0x36

103
00:09:23,410 --> 00:09:30,410
repeated 64 times. Take a hash of this inner
key K, prepended to the message. Then, compute

104
00:09:32,560 --> 00:09:39,560
an outer key by XORing K with a different,
outer pad, say 0x5c repeated 64 times. Hash

105
00:09:39,680 --> 00:09:45,490
this outer key and the result of the inner
hash.

106
00:09:45,490 --> 00:09:49,740
So why doesn’t the previous attack work?
Well, let’s suppose your attacker appends

107
00:09:49,740 --> 00:09:56,740
some information to M. They don’t know K.
The MAC, however, is made up of the hash of

108
00:09:56,790 --> 00:10:02,269
M, not M itself. So appending data to M will
result in a completely different hash value.

109
00:10:02,269 --> 00:10:06,120
The intermediate state of the computation,
leaked in the previous approach, is hidden

110
00:10:06,120 --> 00:10:11,050
through the inner hash.
So this is how MACs are generally computed

111
00:10:11,050 --> 00:10:15,410
today. You take a cryptographic hash of a
transformation of the key and the message,

112
00:10:15,410 --> 00:10:22,410
then a cryptographic hash of a different transformation
of the key and that hash.

113
00:10:23,040 --> 00:10:29,160
So one final problem. Let’s say you want
both confidentiality and integrity. Should

114
00:10:29,160 --> 00:10:33,290
you encrypt the MAC, or MAC the encrypted
data?

115
00:10:33,290 --> 00:10:38,350
The answer is the latter. MAC the encrypted
data. There are some cases where encrypting

116
00:10:38,350 --> 00:10:42,630
the MAC is not always secure. So always MAC
encrypted data.

