1
00:00:00,000 --> 00:00:04,094
So, in this video we talk about
Fragmentation and Assembly.

2
00:00:04,094 --> 00:00:08,095
So here's the basic problem that
fragmentation assembly tries to solve.

3
00:00:08,095 --> 00:00:12,052
Let's say that myth is some some 
machine I'm using at Stanford in the myth

4
00:00:12,052 --> 00:00:15,052
cluster and I wanna request a web page
from Google.

5
00:00:15,052 --> 00:00:20,078
And Google's web page that it sends, this
HTTP response, is ten kilobytes long.

6
00:00:20,078 --> 00:00:25,054
Well a ten kilobyte chunk of data is
pretty big, and the problem is there might

7
00:00:25,054 --> 00:00:30,540
be some hop along the path from Google to
Myth that can't support a ten kilobyte

8
00:00:30,540 --> 00:00:33,061
packet.
In fact in Ethernet the maximum transfer

9
00:00:33,061 --> 00:00:37,047
unit that many speeds of ethernet supports is
1500 bytes.

10
00:00:37,047 --> 00:00:42,125
And so what I need to do is take this ten
kilobyte packet, and break it into a series

11
00:00:42,125 --> 00:00:47,102
of chunks, smaller pieces called fragments
which the network can support.

12
00:00:47,102 --> 00:00:50,881
So imagine like the extreme case if I'm downloading something

13
00:00:50,881 --> 00:00:54,077
really big, I don't want to be sending one
gigabyte packets.

14
00:00:54,077 --> 00:00:58,037
They're gonna occupy the, the channel for
huge amounts of time, so I wanna break

15
00:00:58,037 --> 00:01:01,072
things into smaller chunks.
So in this case, if I had say, an ethernet

16
00:01:01,072 --> 00:01:08,035
frame size of 1.5 kB, I'll need to
split this ten kilobytes into seven

17
00:01:08,035 --> 00:01:15,080
fragments, where these first six could be
1.5 kB each, and the last one say is one

18
00:01:15,080 --> 00:01:20,053
kilobyte.
So that's the process of fragmentation.

19
00:01:20,053 --> 00:01:24,094
And these fragments arrive at myth, and
its job is to assemble

20
00:01:24,094 --> 00:01:28,027
(this is assembly)
So to take these seven fragments, two,

21
00:01:28,027 --> 00:01:33,073
three, four, five, six, seven And
reassemble them to the original ten

22
00:01:33,073 --> 00:01:37,085
kilobytes of data.
And so generally speaking, fragmentation

23
00:01:37,085 --> 00:01:43,060
and assembly occur when a higher layer's
data unit is larger than what a lower

24
00:01:43,060 --> 00:01:46,085
layer can support.
So, fragmentation, the process of taking a

25
00:01:46,085 --> 00:01:50,094
large chunk of data and breaking it into
smaller pieces that the lower layer can

26
00:01:50,094 --> 00:01:54,060
support.
And assembly is in the process of taking

27
00:01:54,060 --> 00:01:57,097
these fragments and reassembling them into
the original data.

28
00:01:57,097 --> 00:02:02,019
This occurs in many different places in
networks at, different layers.

29
00:02:02,019 --> 00:02:04,090
For example, it can occur at the
transport layer.

30
00:02:04,090 --> 00:02:09,034
So, TCP does this when it takes a stream
of data.

31
00:02:09,068 --> 00:02:16,031
It breaks it into segments, which are then
transmitted and reassembled at the other

32
00:02:16,031 --> 00:02:21,027
side into a reliable stream.
And this assembly is now current, end to

33
00:02:21,027 --> 00:02:27,067
end, between the two TCP end points.
Such that a given TCP segment, once it's

34
00:02:27,067 --> 00:02:32,014
generated by an end point, is then
indivisible, and arrives at the other end.

35
00:02:32,014 --> 00:02:36,037
You never see a segment broken into two
separate segments.

36
00:02:36,037 --> 00:02:40,025
Although underneath it might be broken
into packets or frames, as we will show.

37
00:02:40,025 --> 00:02:45,056
Contrast to the network layer, it's
operating on a host to host basis.

38
00:02:45,056 --> 00:02:48,090
This is unlike TCP, where once segment is
sent, that's the segment the end point

39
00:02:48,090 --> 00:02:53,035
will receive, if it arrives.
With IP, at the network layer is possible to

40
00:02:53,035 --> 00:02:57,002
some intermediate node takes the packet
and breaks it up.

41
00:02:57,002 --> 00:03:01,657
So, an IP packet, reversing the network at
some intermediate point, might be broken

42
00:03:01,657 --> 00:03:06,840
into multiple IP fragments, which then the
end point has to reassemble into the

43
00:03:06,840 --> 00:03:12,009
original IP packet.
This is at the network layer, and so can

44
00:03:12,009 --> 00:03:17,012
occur within the network.
Finally, it can also occur at link layer.

45
00:03:17,012 --> 00:03:24,006
So, one example is, there's a link layer
called, Zigbee or 802.15.4 that has a very

46
00:03:24,006 --> 00:03:26,088
small frame size of approximately 120
bytes.

47
00:03:26,088 --> 00:03:30,021
(It's 127 bytes, but you have to include header in
that.)

48
00:03:30,021 --> 00:03:36,006
At times you wanna send large packets on
this frame size like an IPv6 packet, which

49
00:03:36,006 --> 00:03:41,020
can be 1280 bytes.
And so what happens is that the IP layer

50
00:03:41,020 --> 00:03:48,052
passes a 1,280 byte packet to 6-LoPAN
called IPV6 low power personal area

51
00:03:48,052 --> 00:03:51,015
network.
It's to link layer support of IPV6.

52
00:03:51,015 --> 00:03:56,003
And 6-LoPAN, the link layer, breaks it
up into fragments, which are then sent

53
00:03:56,003 --> 00:04:01,905
over the link, reassembled at the other
end of the link Into an original packet.

54
00:04:01,905 --> 00:04:07,593
So in this case the fragments are purely
on the link, and the network layer doesn't

55
00:04:07,593 --> 00:04:10,095
see it.
In the IP case, the network layer sees it.

56
00:04:10,095 --> 00:04:12,355
In the transport case, transport layer
sees it.

57
00:04:12,355 --> 00:04:15,511
But the other actual transport
segments are not broken.

58
00:04:15,511 --> 00:04:20,680
So let's walk through a concrete example.
One of the really common cases

59
00:04:20,680 --> 00:04:24,603
of a fragmentation, or rather it's not
common, people try to avoid it but it's a

60
00:04:24,603 --> 00:04:29,152
very simple mechanism so it's good to
explain, is how fragmentation works in IP,

61
00:04:29,152 --> 00:04:33,662
at the internet protocol.
So let's imagine we have a route between

62
00:04:33,662 --> 00:04:38,391
across three hops where the first and
second, the first and third hops use

63
00:04:38,391 --> 00:04:43,074
ethernet with a maximum transfer unit of
1500 bytes, but the middle hop uses a

64
00:04:43,074 --> 00:04:47,103
point to point link with a maximum
transfer unit of 576 bytes.

65
00:04:47,103 --> 00:04:52,657
This means that at the link layer the
frames can only support, say 576 bytes of

66
00:04:52,657 --> 00:04:55,467
data or 1,500 bytes of data in their
payload.

67
00:04:55,467 --> 00:04:59,815
So what happens now is, some
application, the host on the left wants

68
00:04:59,815 --> 00:05:04,722
to send a 1,400 byte payload.
And so on the first hop, this is fine.

69
00:05:04,722 --> 00:05:09,892
We can take a 1400 byte payload.
An IP header is twenty bytes, and so we'd

70
00:05:09,892 --> 00:05:14,166
have 1420 bytes.
We can then put that in ethernet frame

71
00:05:14,166 --> 00:05:20,704
1420, fits just fine inside ethernet.
But what happens when we hit the second

72
00:05:20,704 --> 00:05:23,603
host?
We can't take this 1400 byte payload and

73
00:05:23,603 --> 00:05:26,494
put it in a PPP frame, because it won't
fit.

74
00:05:26,494 --> 00:05:33,060
So what IP does is it takes the original
packet and splits it into three fragments.

75
00:05:33,060 --> 00:05:37,064
So this is something which is gonna occur
here, at this node.

76
00:05:37,064 --> 00:05:41,800
This node is going to receive an IP packet
with a 1400 byte payload and

77
00:05:41,800 --> 00:05:46,166
its given IP header, Then realizing it
should go out over this PPP link, will

78
00:05:46,166 --> 00:05:52,403
take it and generate three separate IP
packets, I'll show how they're formed by

79
00:05:52,403 --> 00:05:56,765
in a minute, as separate PPP frames with
smaller payloads.

80
00:05:56,765 --> 00:06:04,055
In this case, say 512, 512, and 376 bytes.
But so the trick though is that once this

81
00:06:04,055 --> 00:06:09,571
packet has been fragmented at this second
node, those fragments then pass through

82
00:06:09,571 --> 00:06:14,364
the network unchanged.
So the third node, here, does not

83
00:06:14,364 --> 00:06:18,272
reassemble them.
Instead, what's gonna happen is that it's

84
00:06:18,272 --> 00:06:22,990
going to just forward them along.
And put these three IP fragments inside

85
00:06:22,990 --> 00:06:26,899
ethernet frames and forward them along to
the destination.

86
00:06:26,899 --> 00:06:31,954
And then hopefully the destination will
receive all of them and reassemble the

87
00:06:31,954 --> 00:06:37,471
original data of 1400 bytes.
So, how does this work?

88
00:06:37,471 --> 00:06:44,604
So, if we look at an IP header there are a
couple of fields in it which allow this to

89
00:06:44,604 --> 00:06:48,511
happen.
So basically, there's the "ident" field in

90
00:06:48,511 --> 00:06:52,034
an IP packet here.
And the ident field is what allows the

91
00:06:52,034 --> 00:06:56,697
fragmentation of assembly layer in IP, or
the fragmentation of assembly in IP, to be

92
00:06:56,697 --> 00:07:01,414
able to tell whether or not these are
fragments of the same original packet.

93
00:07:01,414 --> 00:07:05,846
So before fragmentation, we're gonna see a
packet that looks like this, where its

94
00:07:05,846 --> 00:07:09,765
ident is, say, some value X.
And remember here, this is the, more

95
00:07:09,765 --> 00:07:12,838
fragment bit, of the IP header.
This was zero here.

96
00:07:12,838 --> 00:07:16,499
This is the more fragment bit.
And there's the offset field.

97
00:07:16,499 --> 00:07:20,340
And so this is original packet, This
standard IP packet, it's just an

98
00:07:20,340 --> 00:07:22,436
identifier.
There are no fragments.

99
00:07:22,436 --> 00:07:25,919
There's an offset of zero.
And it's just a 1400 byte fragment.

100
00:07:25,919 --> 00:07:30,708
But then after the packet is fragmented,
the more fragment bit is set for all with

101
00:07:30,708 --> 00:07:35,458
the last fragment, so here, this first
fragment, here, and the second fragment,

102
00:07:35,458 --> 00:07:40,000
both have the more fragment bits set to
indicate that more fragments are coming.

103
00:07:40,000 --> 00:07:45,608
The last one does not.
And then the offset field tells a receiver

104
00:07:45,608 --> 00:07:50,893
where this data begins.
And says we could see here, this is a 512

105
00:07:50,893 --> 00:07:56,264
bytes of payload.
And so, this goes from offset zero to 511.

106
00:07:56,264 --> 00:08:04,200
Now this second fragment is, is gonna
start at byte 512 and goes from byte 512

107
00:08:04,200 --> 00:08:07,703
to 1024.
And so the offset field is what indicates

108
00:08:07,703 --> 00:08:10,039
this.
So the offset field is not in terms of

109
00:08:10,039 --> 00:08:14,505
bytes but rather in eight byte chunks.
And so 64 times eight is 512.

110
00:08:14,505 --> 00:08:21,853
And so this tells the receiver that this
second fragment occurs at offset 512 within the

111
00:08:21,853 --> 00:08:26,347
packet at offset zero.
And this is of course at offset 1024.

112
00:08:26,347 --> 00:08:29,401
The ident field is identical in all three
fragments.

113
00:08:29,401 --> 00:08:34,044
And so this means that now an, an endpoint
receiving these three fragments can

114
00:08:34,044 --> 00:08:37,785
properly reassemble the origninal IP
datagram.

115
00:08:37,784 --> 00:08:44,000
And so the combination of the ident field
and the source address is what allows it

116
00:08:44,001 --> 00:08:50,446
to cluster these three fragments together.
And now since the offset field is encoded

117
00:08:50,446 --> 00:08:54,851
in eight byte chunks, that means that each
of these chunks, or these fragments, must

118
00:08:54,851 --> 00:08:59,313
be a multiple of eight
bytes long, except for the last one.

119
00:08:59,313 --> 00:09:04,044
So fragmentation is, in the IP case,
really helpful cause it means an endpoint

120
00:09:04,044 --> 00:09:08,836
can generate an IP packet without having
to worry about what the intermediate

121
00:09:08,836 --> 00:09:14,028
maximum transfer units of the links are.
So it's a great way for an endpoint to be

122
00:09:14,028 --> 00:09:17,509
able to generate packets without having to
know properties of the entire path,

123
00:09:17,509 --> 00:09:22,528
especially if say the path is dynamic.
That being said, in practice, systems

124
00:09:22,528 --> 00:09:27,624
really try to avoid IP fragmentation.
And the reason is you suddenly take in one

125
00:09:27,624 --> 00:09:32,338
packet and make it into multiple packets.
It's now the chances that any one of those

126
00:09:32,338 --> 00:09:35,528
packets might be dropped goes up.
Let's say you know, one percent of all

127
00:09:35,528 --> 00:09:38,849
packets are dropped, suddenly you're increasing
the probability that any one of

128
00:09:38,849 --> 00:09:43,097
those three, and therefore, will be
dropped and therefore the whole original

129
00:09:43,097 --> 00:09:46,551
packet will have to be lost.
IP doesn't support any reliability or

130
00:09:46,551 --> 00:09:50,501
re-transmission of these fragments so if
one fragment is lost, generally you have

131
00:09:50,501 --> 00:09:53,895
to re-transmit all of them that's up to a
higher layer.

132
00:09:53,895 --> 00:09:57,022
So generally you wanna avoid IP
fragmentation.

133
00:09:57,022 --> 00:10:03,457
So one interesting trick that our approach
to the TCP sometimes uses is to actually

134
00:10:03,457 --> 00:10:07,029
choose a segment size to avoid
fragmentation.

135
00:10:07,029 --> 00:10:12,772
Since TCP segments can be of any size that
TCP wants, what it does is it tries to

136
00:10:12,772 --> 00:10:19,161
generate segments which will fit inside IP
packets and not fragment on the path to

137
00:10:19,161 --> 00:10:22,641
destination.
And the way it can do this is by setting

138
00:10:22,641 --> 00:10:26,105
the don't fragment bit.
And so say a TCP connection window opens

139
00:10:26,105 --> 00:10:30,766
up, it can say choose, well, I'm gonna try
sending, let's just say, a standard

140
00:10:30,766 --> 00:10:36,617
Ethernet frame of 1500 bytes.
I'm gonna set the, the don't fragment bit

141
00:10:36,617 --> 00:10:41,580
and if it gets an ICMP error saying, oh,
you know, couldn't send this thing

142
00:10:41,580 --> 00:10:45,731
couldn't, I had to fragment it and I
couldn't, then it says I'll try something

143
00:10:45,731 --> 00:10:46,961
else.
There must be some smaller link.

144
00:10:46,961 --> 00:10:48,602
Oh, I'll see if maybe there's a 512 byte
PPP link.

145
00:10:48,602 --> 00:10:51,431
And there's a bunch of ways you can search
for this.

146
00:10:51,431 --> 00:10:53,619
One is to do a binary search, that's
expensive.

147
00:10:53,619 --> 00:10:57,234
You can also try common, try common sizes
like 1500 bytes.

148
00:10:57,234 --> 00:11:00,375
There is an RFC that talks about the
options.

149
00:11:00,375 --> 00:11:03,489
But this is an approach where TCP can
actually sense the

150
00:11:03,489 --> 00:11:07,628
properties of the path for connection, and
based on that pick an optimal segment size

151
00:11:07,628 --> 00:11:13,248
such that it doesn't have fragmentation,
but it's also able to minimize header

152
00:11:13,248 --> 00:11:15,445
overhead.
It's, has as much payload per header,

153
00:11:15,445 --> 00:11:19,046
given that it's minimizing the number of
segments that it sends.

